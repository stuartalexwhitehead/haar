\chapter{Evaluation}
  The two software components of this project---the IoT framework and demonstration application---were successfully implemented. Most importantly, they \textit{work} and demonstrate the execution of some arbitrary IoT devices. Going into this project there was always a risk that a working solution could not be developed given the available resources, so the fact a solution has been developed is important to note. 

  The purpose of this chapter is to evaluate the effectiveness of the two main software components. The IoT framework and demonstration application will first be compared against the functional requirements in Chapter \ref{Chapter:Specification} (Specification). There are some features which were not implemented and this will be discussed.

  A small load testing experiment was also conducted. The data generated by a sensor must traverse a number of hardware and software components before being persisted to a server-side database. The aim of this experiment was to stress test the end-to-end system with regards to packet volume. A minumum inter-packet rate was established from the results of this experiment.

  Finally, this chapter will finish off by discussing areas which could be improved. Although the project did meet the main goals and functional requirements, there are a number of improvements which would be advised for a production-ready application.

  \section{Acceptance Testing}
    Acceptance testing is the stage of the development lifecycle where software is determined to be fit for purpose. In order to be fit for purpose, software must conform to the requirements specification as defined earlier in the process.

    The demonstration application also helps to validate the implementation of the IoT framework. Since the purpose of the framework is to provide a starting point for IoT application, the fact that an application has been developed is evidence of functioning software.

    \subsection{Haar Engine}
      33 out of the 36 of the Haar Engine requirements were successfully implemented. A complete list of the requirements and their status can be seen in Table \ref{table:haar-engine-acceptance} of Appendix \ref{chapter:haar-engine-acceptance-tests}. The features which were not implemented are granular user access control and a DB connector API.

      The first of those features---granular access control---was to enable users to grant specific access for private devices to other users. As it stands, devices can be classified as public or private. It was decided that granular user access control such as this would be unfeasible within the time contraints. If a user would like to grant access for a device to another user, they have the opportunity to make it a public device instead.

      The second and third requirements which were not implemented are related to one feature, a DB connector API. This was discussed briefly as part of Chapter \ref{chapter:implementation}. In order to be as extensible as possible the initial requirements stated a DB connector API should allow different database types to be changed transparently. Again, this feature was determined to be too complex for the given constraints. Rather than provide the option for a variety of strict database management systems, Haar Engine proves a single, highly flexible database management system in the form of MongoDB.

    \subsection{Haar}
      24 out of 31 of the Haar demonstration application requirements were fully implemented. A complete list of the requirements and these status can be found in Table \ref{table:haar-acceptance} of Appendix \ref{chapter:haar-acceptance}. The requirements where were not implemented include: a user access control UI, device connectivity status, real-time virtual control and specialised visualisation tools.

      First of all, an interface for managing user access control was not created. As was described above, the IoT framework did not implement granular user access control. This means that no user access control endpoints existed for the interface to call.

      The remaining requirements were not implemented due to time contstraints rather than a lack of technical capability. For example, on idea was to represent real-time data streams with specialised visualation tools, such as a virtual thermometer for the thermometer sensor. Another idea was to enable a virtual control of output devices, such as a colour wheel which would control the RGB LED actuator. These features were `nice-to-haves' rather than critical application components.

  \section{Inter-Packet Rate}
    Once a fully-functioning system was developed, a small experiment was undertaken in order to measure \textit{how} well the system performed. The metric used to evaluate the system is an inter-packet transmission rate. This was an interesting experiment because it tested the effectiveness of the system as a whole and identified potential bottlenecks.

    The experiment was conducted over the course of one day with the following method. One of the sensor devices was reprogrammed to send exactly 100 measurements at a specific interval (initially 2000ms). Once the sensor device had sent all 100 measurements (as signalled by the onboard LED), the database would be queried for a count of received packets and then emptied. This process was repeated 10 times in order to obtain an average before decreasing the interval.

    The results obtained from this experiment (shown in Figure x.x.) illustrate a number of points. First of all, the smallest inter-packet rate that was successfully tested was 60ms. When an inter-packet rate of less than this was attempted, the Arduino itself began to display error activity suggesting that for this implementation, it can handle a minimum of 60ms between taking measurements.

    An inter-packet rate of 90ms was the smallest possible value without any error activity. When reviewing the capability of each device in the system, it was discovered that the XBee radio chips have an input buffer of 202 bytes. The payload alone for each measurement could be 40 bytes in size and this does not include any header bytes. As a result, the XBee radio chip could be the source of the error activity due to a buffer overflow.

  \section{Improvements}
    % OAuth security practices
    % MQTT server
    % Service architecture
    % internal event bus
    % Prototype
      % Get XBee sleep mode working
      % Debug mode
      % Use more specialised ZigBee radio chips
